<html><head><title>Books24x7.com - Referenceware for Professionals</title>
	
		
		<meta http-equiv="REFRESH" content="900; URL=/default.asp">
		<link rel="stylesheet" href="Indexes1_files/xpolecat.css">
			<link rel="stylesheet" type="text/css" href="Indexes1_files/ie000000.css"></head><body leftmargin="0" topmargin="0" rightmargin="0" bgcolor="#ffffff" link="#122eb2">
		<div style="z-index: 1; left: 0px; position: relative; top: 0px; text-align: left;"></div>
		<map name="navmap"><area shape="RECT" coords="0,0,93,29" href="http://library.books24x7.com/topics.asp" alt="Find Books" target="_self"><area shape="RECT" coords="94,0,204,29" href="http://library.books24x7.com/bookshelf.asp" alt="Go to My Bookshelf" target="_self"><area shape="RECT" coords="205,0,279,29" href="http://library.books24x7.com/home.asp" alt="Home" target="_self"><area shape="RECT" coords="280,0,354,29" href="http://library.books24x7.com/login.asp" alt="Login" target="_self"><area shape="RECT" coords="355,0,452,29" href="http://library.books24x7.com/account.asp" alt="Account Info" target="_self"><area shape="RECT" coords="453,0,508,29" href="http://library.books24x7.com/help.asp" alt="Help" target="_self"><area shape="RECT" coords="509,0,603,29" href="http://library.books24x7.com/feedback.asp" alt="Submit Feedback" target="_self">
			
			
			
			
			
			
			
		</map>
		<table bgcolor="#336699" border="0" cellpadding="0" cellspacing="0" width="100%">
			<tbody><tr>
				<td></td>
			</tr>
		</tbody></table>
		<table bgcolor="#ffffff" border="0" cellpadding="0" cellspacing="0" width="700">
			<tbody><tr>
				<td rowspan="2" bgcolor="#000000" height="700" width="1"><img src="Indexes1_files/transdot.gif" alt="" height="700" hspace="0" vspace="0" width="1"></td>
				<td rowspan="2" height="700" width="20"><img src="Indexes1_files/transdot.gif" alt="" height="1" hspace="0" vspace="0" width="20"></td>
				<td align="left" valign="top" width="679"><a name="skip"></a><div class="b24-bookmeta" xmlns:dc="http://purl.org/dc/elements/1.0/">
<a name="skip">							</a><table border="0" cellpadding="0" cellspacing="2" width="100%">
								<tbody><tr>
									<td align="right" valign="top" width="100"><a border="0" href="http://library.books24x7.com/book/id_3429/toc.asp?bookid=3429"><img src="Indexes1_files/07356127.gif" alt="Microsoft SQL Server 2000 Performance Tuning Technical Reference" align="left" border="0" height="108" width="83"></a></td>
									<td width="2"></td>
									<td align="left" valign="top">
										<table border="0" cellpadding="0" cellspacing="4" width="100%">
											<tbody><tr>
												<td colspan="2" align="left" valign="top"><a border="0"><span class="b24-bookchaptertitle">Chapter 18 - 
 Using and Tuning Indexes</span></a></td>
											</tr>
											<tr>
												<td colspan="2" align="left" valign="top">Microsoft SQL Server 2000 Performance 
													Tuning Technical Reference</td>
											</tr>
											<tr>
												<td align="left" valign="top"><span class="b24-bookauthor">by&nbsp;Edward Whalen&nbsp;et al.</span>&nbsp;
												</td>
												<td align="right" valign="top"></td>
											</tr>
											<tr>
												<td colspan="2" align="left" valign="top"><span class="b24-bookimprint">Microsoft Press</span><span class="b24-bookcwdate"> © 2001</span></td>
											</tr>
										</tbody></table>
									</td>
								</tr>
							</tbody></table>
<a name="skip">						</a></div>
<a name="skip">						</a><table border="0" cellpadding="0" cellspacing="0" width="100%">
							<tbody><tr>
								<td align="center">
									<table border="0" cellpadding="0" cellspacing="5" width="85%">
									</table>
								</td>
							</tr>
							<tr>
								<td bgcolor="#000000"><img src="Indexes1_files/transdot.gif" alt="" border="0" height="1" width="1"></td>
							</tr>
						</tbody></table>
<a name="skip">					</a>
					<div xmlns:esi="i.am.akamai"><!--Bypass:First Viewer Page:Trial user: Time:Tue, 15 Apr 2003 18:38:41 UTC--><div><!--XML Creation Time:Tue, 15 Apr 2003 18:08:27 UTC-->
							<div class="chapter">
								<a name="chapter.A5AA041F-53A5-11D6-A596-00045A54F279"></a>
								<h1 class="chapter-title">
									<a name="822"></a><a name="wbp23Ch18P1"></a>
									<span class="chapter-titlelabel">Chapter 18: </span>
									Using and Tuning <font color="#cc00cc">Indexes</font>
								</h1>
								<p class="first-para">
									<a name="823"></a><a name="beginpage.A5AA0420-53A5-11D6-A596-00045A54F279"></a>The 
									use of <font color="#cc00cc">indexes</font> on your tables is critical to the 
									performance of data operations. But you must understand how to use <font color="#cc00cc">
										indexes</font> to benefit from them. In this chapter, we discuss index 
									fundamentals as well as the different types of <font color="#cc00cc">indexes</font>
									and when you should use them. We also give general guidelines for building <font color="#cc00cc">
										indexes</font>, show how to analyze and tune <font color="#cc00cc">indexes</font>
									for better query performance, and discuss how to form queries so they use the <font color="#cc00cc">
										indexes</font> you create.</p>
								<div class="section">
									<h2 class="sect2-title">
										<a name="824"></a><a name="wbp23Ch18P3"></a>Index Fundamentals
									</h2>
									<p class="first-para">An <i class="emphasis">index</i> is an auxiliary data 
										structure used to assist Microsoft <font color="#cc00cc">SQL</font> <font color="#cc00cc">
											Server</font> <font color="#cc00cc">2000</font> in accessing data. With <font color="#cc00cc">
											SQL</font> <font color="#cc00cc">Server</font> <font color="#cc00cc">2000</font>,
										<font color="#cc00cc">indexes</font> are created on tables or views. One table 
										or view can have more than one index that refers to its data. Depending on the 
										type of index, the index data can be stored either with the table data or 
										separate from it. All types of <font color="#cc00cc">indexes</font> work in 
										fundamentally the same way. A database index is like an index in a book: you 
										can look up the term in the index to quickly find the data instead of searching 
										every page.</p>
									<p class="para">Without an index, all data is retrieved through table scans, which 
										means that all the data in a table must be read and compared against the data 
										you request. You should avoid table scans because they generate a lot of I/O 
										(unless you want to select a high percentage of rows from the table). Large 
										tables consume far too many system resources when a table scan is performed. By 
										using an appropriate index, you can greatly reduce the number of I/O operations 
										needed to find the correct data rows. This speeds up access to the data and 
										frees system resources for other operations.</p>
									<p class="para">
										<font color="#cc00cc">Indexes</font> are typically structured as <i class="emphasis">
											B-trees.</i> The B-tree structure begins with a <i class="emphasis">root node</i>, 
										which is the start of the index. The root node contains index rows (that is, 
										rows of index data) that contain ranges of index key values and pointers to the 
										next index nodes, which are called <i class="emphasis">branch nodes</i>. Branch 
										nodes in turn contain index rows with further refined ranges of values that 
										point to other branch nodes. Each level of branch nodes is called an <i class="emphasis">
											index level</i>.<a name="825"></a><a name="beginpage.A5AA0421-53A5-11D6-A596-00045A54F279"></a>
									</p>
									<p class="para">The nodes in the lowest level of the index tree are called the <i class="emphasis">
											leaf nodes</i>. The leaf nodes contain the index key data and either 
										information about where the referenced data resides or the data itself, 
										depending on whether the index is nonclustered or clustered. (These two index 
										types are described in the &#8220;<a role="targetype:section" class="internaljump" href="http://library.books24x7.com/book/id_3429/viewer.asp?#wbp23Ch18P17">Types 
											of <font color="#cc00cc">Indexes</font></a>&#8221; section later in this 
										chapter.) The number of index levels that must be traversed to reach a leaf 
										node determines the number of I/Os necessary to find the requested row of data. <a role="targetype:figure" class="internaljump" href="http://library.books24x7.com/book/id_3429/viewer.asp?#wbp23Ch18P9">
											Figure 18.1</a> illustrates the terms discussed so far. The nodes do not 
										necessarily contain only two pointers each, as shown in <a role="targetype:figure" class="internaljump" href="http://library.books24x7.com/book/id_3429/viewer.asp?#wbp23Ch18P9">
											Figure 18.1</a>. Actually, each index row in a node contains a pointer to 
										another node, as shown in <a role="targetype:figure" class="internaljump" href="http://library.books24x7.com/book/id_3429/viewer.asp?#wbp23Ch18P11">
											Figure 18.2</a>.</p>
									<div class="figure">
										<a name="826"></a><a name="wbp23Ch18P9"></a>
										<span class="figuremediaobject">
											<a href="http://library.books24x7.com/viewer.asp?bkid=3429&amp;image_src=http://images.books24x7.com/bookimages/id_3429/f18ql01%5F0%2Ejpg&amp;image_id=191&amp;previd=IMG_191&amp;titlelabel=Figure+18%2E1%3A+&amp;title=+A+sample+index%2E" name="IMG_191" target="_parent"><img src="Indexes1_files/f18ql010.jpg" alt="Click To expand" border="0" height="175" width="350"></a></span>
										<br style="line-height: 1;">
										<span class="figure-title"><span class="figure-titlelabel">Figure 18.1: </span><b class="bold">
											</b>A sample index.</span>
									</div>
									<div class="figure">
										<a name="827"></a><a name="wbp23Ch18P11"></a><a name="828"></a><a name="wbp23Ch18P10">
										</a>
										<span class="figuremediaobject">
											<a href="http://library.books24x7.com/viewer.asp?bkid=3429&amp;image_src=http://images.books24x7.com/bookimages/id_3429/f18ql02%5F0%2Ejpg&amp;image_id=192&amp;previd=IMG_192&amp;titlelabel=Figure+18%2E2%3A+&amp;title=+An+index+structure%2E" name="IMG_192" target="_parent"><img src="Indexes1_files/f18ql020.jpg" alt="Click To expand" border="0" height="236" width="350"></a></span>
										<br style="line-height: 1;">
										<span class="figure-title"><span class="figure-titlelabel">Figure 18.2: </span><b class="bold">
											</b>An index structure.</span>
									</div>
									<p class="para">
										<font color="#cc00cc">Indexes</font> are helpful not only with SELECT 
										statements, but with UPDATE and DELETE statements as well, because <font color="#cc00cc">
											SQL</font> <font color="#cc00cc">Server</font> must find a row before it 
										can update or delete it. For the remainder of this chapter, when we discuss 
										finding data or performing queries we are referring to any of these three types 
										of operations.</p>
									<div class="section">
										<h3 class="sect3-title">
											<a name="829"></a><a name="wbp23Ch18P13"></a>Index Keys</h3>
										<p class="first-para">
											<i class="emphasis">Index keys</i> are the columns for which an index is 
											created. To access a row of data through the index, you must include an index 
											key value or values within the WHERE clause of the <font color="#cc00cc">SQL</font>
											statement. You can create an index on one or more index key columns. New to <font color="#cc00cc">
												SQL</font> <font color="#cc00cc">Server</font> <font color="#cc00cc">2000</font>, 
											you can define the sort order for any index as ascending or descending. While 
											we assume an ascending sort order in this chapter, you should carefully 
											consider and choose the sort order on a case-by-case basis.</p>
										<p class="para">An index with only one index key is called a <i class="emphasis">simple 
												index. </i>For example, a simple index might be created on the customer ID 
											column of a customer table. This index is used for queries that search for a 
											particular customer ID. Note that the customer ID must be included in the WHERE 
											clause of the <font color="#cc00cc">SQL</font> statement in order for the index 
											to be used.</p>
										<p class="last-para">An index with more than one key column is called a <i class="emphasis">
												composite index</i>. A composite index might be created on the last-name 
											column and first-name column of the customer table. This index is used for 
											queries that search for a particular customer by last name only, by first name 
											only, or by last name and first name. For more information on index keys, see 
											the &#8220;<a href="http://library.books24x7.com/viewer.asp?bkid=3429&amp;destid=842#842" target="_parent" class="chapterjump">Choosing the Index Key Columns</a>&#8221; section later in 
											this chapter.</p>
										<a name="sDE5A75D9-85D7-4F33-A531-ECA4EB473490"></a>
									</div>
									<div class="section">
										<h3 class="sect3-title">
											<a name="830"></a><a name="wbp23Ch18P17"></a>Types of <font color="#cc00cc">Indexes</font>
										</h3>
										<p class="first-para">
											<font color="#cc00cc">SQL</font> <font color="#cc00cc">Server</font> supports 
											two major types of <font color="#cc00cc">indexes</font>: clustered and 
											nonclustered. For either type of index, you can specify whether the index 
											should be a unique index. (A unique index is sometimes considered a third type 
											of index, but it is actually a characteristic of a clustered or nonclustered 
											index.) Another type of index, the <i class="emphasis"><a role="targetype:section" class="internaljump" href="http://library.books24x7.com/book/id_3429/viewer.asp?#wbp23Ch18P44">
													full-text index</a></i>, is more like a catalog. The <a role="targetype:section" class="internaljump" href="http://library.books24x7.com/book/id_3429/viewer.asp?#wbp23Ch18P44">
												full-text index</a> has characteristics that differ from those of clustered 
											and nonclustered <font color="#cc00cc">indexes</font> and so falls into a 
											separate category. The following sections explain the characteristics of each 
											type of index and discuss when each type is useful.</p>
										<div class="section">
											<h4 class="sect4-title">Clustered Index
											</h4>
											<p class="first-para">A <i class="emphasis">clustered index</i> indicates the order 
												in which table data should be physically stored. The table data is sorted and 
												stored according to the key column or columns specified for the clustered 
												index. This type of index is analogous to a dictionary, which stores 
												information in alphabetical order and provides guide words to help locate the 
												information quickly; the data is found on the same page as its guide words. The 
												clustered index is similar in that it includes the index pages as well as the 
												actual data pages, which make up the lowest level (the leaf node) of the 
												clustered index, as shown in <a role="targetype:figure" class="internaljump" href="http://library.books24x7.com/book/id_3429/viewer.asp?#wbp23Ch18P22">
													Figure 18.3</a> on the following page. Each row in the root node points to 
												a branch node, whose rows can point to other branch nodes (only one set of 
												branch nodes is shown in <a role="targetype:figure" class="internaljump" href="http://library.books24x7.com/book/id_3429/viewer.asp?#wbp23Ch18P22">
													Figure 18.3</a>). The last set of branch nodes point to the leaf nodes. 
												When you get to the leaf nodes, you have reached the actual data page as well. 
												Because the data is physically stored in a specific order, you can create only 
												one clustered index per table. <a name="831"></a><a name="beginpage.A5AA0422-53A5-11D6-A596-00045A54F279">
												</a>
											</p>
											<div class="figure">
												<a name="832"></a><a name="wbp23Ch18P22"></a>
												<span class="figuremediaobject">
													<a href="http://library.books24x7.com/viewer.asp?bkid=3429&amp;image_src=http://images.books24x7.com/bookimages/id_3429/f18ql03%5F0%2Ejpg&amp;image_id=193&amp;previd=IMG_193&amp;titlelabel=Figure+18%2E3%3A+&amp;title=+The+structure+of+a+clustered+index%2E" name="IMG_193" target="_parent"><img src="Indexes1_files/f18ql030.jpg" alt="Click To expand" border="0" height="192" width="250"></a></span>
												<br style="line-height: 1;">
												<span class="figure-title"><span class="figure-titlelabel">Figure 18.3: </span><b class="bold">
													</b>The structure of a clustered index.</span>
											</div>
											<p class="para">Clustered <font color="#cc00cc">indexes</font> are very efficient 
												when created on columns that will be searched for a certain range of values. 
												For example, you might want to frequently retrieve all rows from a customer 
												table that contain last names that start with letters <i class="emphasis">A</i> 
												through <i class="emphasis">C</i>. When you use a clustered index on the 
												last-name column, the data is physically stored in order of the last name. When 
												the query is performed, the row with the first selected value is found (the 
												first occurrence of a last name that starts with <i class="emphasis">A</i>); 
												the subsequent rows are guaranteed to be physically adjacent. Therefore the 
												rows are retrieved quickly until the last row containing a last name that 
												starts with <i class="emphasis">C</i> is reached.
											</p>
											<p class="para">Another case in which clustered <font color="#cc00cc">indexes</font>
												are particularly efficient is when you frequently need to sort the data that is 
												retrieved. If you create a clustered index on the column or columns that you 
												would need to sort by, then the rows are physically stored in that order (and 
												thus presorted), eliminating the overhead of sorting the data after it is 
												retrieved.</p>
											<p class="para">Clustered <font color="#cc00cc">indexes</font> are also efficient 
												when you frequently perform queries to find a row that contains a specific 
												value for a column that contains all unique values, such as a customer ID 
												column (assuming each customer has a unique customer ID). Creating a clustered 
												index on that column provides the fastest path to retrieve a row in this case.
											</p>
											<p class="para">For reasons described later, as a general rule you should make 
												clustered <font color="#cc00cc">indexes</font> unique, which means that no 
												duplicates of that column can be inserted into the table. If the clustered 
												index is unique, <font color="#cc00cc">SQL</font> <font color="#cc00cc">Server</font>
												provides an error message if you attempt to insert a duplicate value into the 
												index key column or columns. If your clustered index is not unique, <font color="#cc00cc">
													SQL</font> <font color="#cc00cc">Server</font> generates a unique 
												identifier for you. This unique identifier is not visible to the user.<a name="833"></a><a name="beginpage.A5AA0423-53A5-11D6-A596-00045A54F279"></a>
											</p>
											<p class="para">Because you can have only one clustered index per table, you must 
												look at what search conditions your queries will use (such as searching for a 
												range of values or for a particular customer), how often they will be 
												performed, and how much data is involved in each query (that is, the size of 
												the table to be queried). You want to create the clustered index so that it 
												will best benefit your situation. For instance, if you create the clustered 
												index to service a particular query that is run only once each night, you might 
												cause performance to suffer for other queries that run more often during the 
												day by not building the clustered index to satisfy the more frequently run 
												queries. On the other hand, the nightly query might take too much time to 
												complete if the clustered index is not built to speed that query.</p>
											<table class="note" border="0" cellpadding="0" cellspacing="0">
												<tbody><tr>
													<td class="admon-check" valign="top"></td>
													<td class="admon-title" valign="top">Note&nbsp;</td>
													<td class="admon-body" valign="top">
														<p class="first-para">
															When you create a primary key constraint on a column, <font color="#cc00cc">SQL</font>
															<font color="#cc00cc">Server</font> creates a unique clustered index for that 
															constraint if one does not already exist and if you do not explicitly specify 
															that the index should be a unique non-clustered index. The main difference 
															between a PRIMARY KEY and a UNIQUE CONSTRAINT is that a PRIMARY KEY can not 
															contain any NULL values, while a UNIQUE CONSTRAINT can contain a single NULL 
															value. (In stark contrast, an Oracle database allows multiple NULL values 
															within a UNIQUE CONSTRAINT.)</p>
													</td>
												</tr>
											</tbody></table>
											<a name="sDE5A75D9-85D7-4F33-A531-ECA4EB473490"></a>
										</div>
										<div class="section">
											<h4 class="sect4-title">Nonclustered Index</h4>
											<p class="first-para">Unlike the clustered index, a <i class="emphasis">nonclustered 
													index</i> does not contain the actual table data in its leaf nodes, as 
												shown in <a role="targetype:figure" class="internaljump" href="http://library.books24x7.com/book/id_3429/viewer.asp?#wbp23Ch18P32">
													Figure 18.4</a>. Instead, the index itself is completely separate from the 
												data, like a book with an index in the back&#8212;the index indicates which page to 
												go to, but the data is not with the index itself. The leaf nodes of the 
												nonclustered index contain index rows that hold index data and information that 
												specifies the exact location of a row.
											</p>
											<div class="figure">
												<a name="834"></a><a name="wbp23Ch18P32"></a><a name="835"></a><a name="wbp23Ch18P31">
												</a>
												<span class="figuremediaobject">
													<a href="http://library.books24x7.com/viewer.asp?bkid=3429&amp;image_src=http://images.books24x7.com/bookimages/id_3429/f18ql04%5F0%2Ejpg&amp;image_id=194&amp;previd=IMG_194&amp;titlelabel=Figure+18%2E4%3A+&amp;title=+The+structure+of+a+nonclustered+index%2E" name="IMG_194" target="_parent"><img src="Indexes1_files/f18ql040.jpg" alt="Click To expand" border="0" height="249" width="254"></a></span>
												<br style="line-height: 1;">
												<span class="figure-title"><span class="figure-titlelabel">Figure 18.4: </span><b class="bold">
													</b>The structure of a nonclustered index.</span>
											</div>
											<p class="para">The location information can be one of two types, depending on 
												whether there is a clustered index on the table. If there is a clustered index, 
												then for each row the key value of the clustered index is stored in the leaf 
												node of the nonclustered index as the row locator. This value is used to locate 
												the data, which resides in the leaf node of the clustered index. If the 
												clustered index is not a unique index, <font color="#cc00cc">SQL</font> <font color="#cc00cc">
													Server</font> assigns an internal value to any duplicate index key values 
												to make them unique for use with nonclustered <font color="#cc00cc">indexes</font>. 
												The internal values are not visible to users. Because your clustered index key 
												is appended to any nonclustered index, generally you should make your clustered 
												index key as small as possible.
											</p>
											<p class="para">If there is no clustered index on the table, then each leaf node 
												contains a row ID as the row locator, instead of a key value of the clustered 
												index. The row ID is a pointer made up of the file ID, page number, and row 
												number in the page. This pointer indicates exactly where the row is found, so 
												that once the row ID is reached, only one more I/O is required to read the row 
												of data. <a role="targetype:figure" class="internaljump" href="http://library.books24x7.com/book/id_3429/viewer.asp?#wbp23Ch18P32">
													Figure 18.4</a> illustrates the structure of a nonclustered index.</p>
											<p class="last-para">
												<font color="#cc00cc">SQL</font> <font color="#cc00cc">Server</font> allows a 
												maximum of 249 nonclustered <font color="#cc00cc">indexes</font> on a table. 
												Remember that the more <font color="#cc00cc">indexes</font> you have, the more 
												overhead is incurred during inserts, updates, and deletes because the index 
												pages must be maintained to include those modifications as well. Thus you do 
												not want to create unnecessary <font color="#cc00cc">indexes</font>.</p>
											<a name="sDE5A75D9-85D7-4F33-A531-ECA4EB473490"></a>
										</div>
										<div class="section">
											<h4 class="sect4-title">Indexed Views</h4>
											<p class="first-para">New to <font color="#cc00cc">SQL</font> <font color="#cc00cc">Server</font>
												<font color="#cc00cc">2000</font> is the ability to index a view. This is a 
												dangerous ability because it can significantly increase the number of I/Os in 
												the system, but it offers solutions to many of the most common query problems. 
												If <font color="#cc00cc">SQL</font> <font color="#cc00cc">Server</font> recognizes 
												that an indexed view satisfies a query request, even if <font color="#cc00cc">SQL</font>
												<font color="#cc00cc">Server</font> does not reference the view, it uses that 
												view&#8217;s index to satisfy the query.
											</p>
											<p class="last-para">One drawback to an indexed view is that you must create a 
												clustered index on a PRIMARY KEY that you define on the view. This means that 
												each view to be indexed must have a column or set of columns that are always 
												unique. Many views are not designed to meet this requirement, so satisfying it 
												might require some creative thinking.</p>
											<a name="sDE5A75D9-85D7-4F33-A531-ECA4EB473490"></a>
										</div>
										<div class="section">
											<h4 class="sect4-title">
												<font color="#cc00cc">Indexes</font> on Calculated Columns</h4>
											<p class="first-para">Also new to <font color="#cc00cc">SQL</font> <font color="#cc00cc">
													Server</font> <font color="#cc00cc">2000</font> is the ability to index a 
												calculated column. Previous versions of <font color="#cc00cc">SQL</font> <font color="#cc00cc">
													Server</font> allowed the data architect to define a virtual column that 
												resulted from a calculation based on one or more other columns in the same 
												table. This was great until an unwary user attempted to query the table using 
												the virtual column as the only criteria. Without an index on the calculated 
												column, <font color="#cc00cc">SQL</font> <font color="#cc00cc">Server</font> had 
												to perform a table scan and calculate every possible result to satisfy the 
												query. As you can imagine, a table with a billion rows would significantly 
												hinder the system performance. Such queries are common in data warehousing, 
												where a fact table has a calculated measure. In such an environment, you might 
												want to locate any customer that matches a given value. Because these are not 
												highly volatile values, it can be extremely helpful to system performance to 
												create an index against the calculated measure. Be aware, though, that changes 
												to values of any of the base columns used to generate the calculated column 
												force an index update.<a name="836"></a><a name="beginpage.A5AA0424-53A5-11D6-A596-00045A54F279"></a>
											</p>
											<a name="sDE5A75D9-85D7-4F33-A531-ECA4EB473490"></a>
										</div>
										<div class="section">
											<h4 class="sect4-title">Unique Index</h4>
											<p class="first-para">A <i class="emphasis">unique index</i> is either a clustered 
												or a nonclustered index that is created specifically to be unique. Values 
												inserted in the key value column or columns must be unique; duplicates of the 
												key values are not allowed. For composite keys, the combination of the values 
												must be unique. For example, if you have a unique index created on the 
												last-name and first-name columns of a customer table, no duplicate last-name 
												and first-name pairs can be inserted; you can insert two or more rows with the 
												same last name, but they must have unique first names and vice versa. You would 
												want the unique index to be on only one column when you want a single column to 
												be unique in itself, such as a column that contains social security numbers. 
												You can create a unique index on that column to ensure that there are no 
												duplicate social security numbers in the table.</p>
											<p class="last-para">You can also use another method to enforce uniqueness of data 
												for certain columns&#8212;you can create a UNIQUE constraint. When you create a 
												UNIQUE constraint, <font color="#cc00cc">SQL</font> <font color="#cc00cc">Server</font>
												creates a unique nonclustered index to enforce the constraint. Once you have a 
												unique index on a table, <font color="#cc00cc">SQL</font> <font color="#cc00cc">Server</font>
												prevents duplicates from being entered into the table and displays an error 
												message stating that a duplicate row insert was attempted.
											</p>
											<a name="sDE5A75D9-85D7-4F33-A531-ECA4EB473490"></a>
										</div>
										<div class="section">
											<h4 class="sect4-title">
												<a name="837"></a><a name="wbp23Ch18P44"></a>Full-Text Index
											</h4>
											<p class="first-para">The <i class="emphasis">full-text index</i> is more complex 
												than the previously discussed <font color="#cc00cc">indexes</font>. The 
												full-text index is actually like a catalog. Instead of simply searching in an 
												ordered B-tree fashion, the full-text index allows you to search by groups of 
												keywords. The full-text index is part of the Microsoft Search service. It is 
												used extensively in Web site search engines and other text-based operations.</p>
											<p class="para">Unlike B-tree <font color="#cc00cc">indexes</font>, the full-text 
												index is stored externally to the database, but is maintained by the database. 
												This is done so that the index can maintain its own structure. The following 
												restrictions apply to creating and maintaining full-text <font color="#cc00cc">indexes</font>:</p>
											<ul class="itemizedlist">
												<li class="first-listitem">
													<p class="first-para">Full-text <font color="#cc00cc">indexes</font> can be created 
														only on <b class="bold">char</b> and <b class="bold">varchar</b> column types.</p>
												</li><li class="listitem">
													<p class="first-para">Only one full-text index is allowed per table.</p>
												</li><li class="listitem">
													<p class="first-para">A full-text index is not automatically updated, unlike B-tree <font color="#cc00cc">
															indexes</font>.</p>
												</li><li class="listitem">
													<p class="first-para">A full-text index is created, managed, and dropped using 
														stored procedures or the Full-Text Indexing wizard.</p>
												</li>
											</ul>
											<p class="para">The full-text index has a wealth of features that cannot be found 
												in normal B-tree <font color="#cc00cc">indexes</font>. Because this index is 
												designed to be a text search engine, it supports more than normal text search 
												capabilities. With the full-text index you can perform the following types of 
												operations:</p>
											<ul class="itemizedlist">
												<li class="first-listitem">
													<p class="first-para">Searching for words or phrases</p>
												</li><li class="listitem">
													<p class="first-para">Searching for single words or groups of words</p>
												</li><li class="listitem">
													<p class="first-para">Searching for words that are similar to each other<a name="838"></a><a name="beginpage.A5AA0425-53A5-11D6-A596-00045A54F279"></a>
													</p>
												</li>
											</ul>
											<table class="note" border="0" cellpadding="0" cellspacing="0">
												<tbody><tr>
													<td class="admon-check" valign="top"></td>
													<td class="admon-title" valign="top">Note&nbsp;</td>
													<td class="admon-body" valign="top">
														<p class="first-para">
															To use full-text indexing, you must have installed the Full-Text Search service 
															with <font color="#cc00cc">SQL</font> <font color="#cc00cc">Server</font> Standard 
															or Enterprise Edition. To select the option, you must choose the custom 
															install.</p>
													</td>
												</tr>
											</tbody></table>
											<p class="last-para">See <font color="#cc00cc">SQL</font> <font color="#cc00cc">Server</font>
												Books Online for more information on the full-text index.
											</p>
											<a name="sDE5A75D9-85D7-4F33-A531-ECA4EB473490"></a>
										</div>
										<a name="sDE5A75D9-85D7-4F33-A531-ECA4EB473490"></a>
									</div>
									<a name="sDE5A75D9-85D7-4F33-A531-ECA4EB473490"></a>
								</div>
							</div>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td colspan="1" bgcolor="#ffffff" width="679"><table border="0" cellpadding="0" cellspacing="0" width="100%">
						<tbody><tr>
							<td colspan="2" align="left" height="10" valign="middle"><img src="Indexes1_files/blackdot.gif" alt="" border="0" height="1" width="100%"></td>
						</tr>
						<tr>
							<td height="9" width="98%"><a href="http://library.books24x7.com/book/id_3429/help.asp?item=membership" target="_top" border="0"><span style="font-size: 10px; color: rgb(204, 0, 0); font-family: Arial,Helvetica,sans-serif; text-decoration: none;"></span></a></td>
						</tr>
						<tr>
							<td>&nbsp;</td>
						</tr>
						<tr>
							<td width="98%"><span style="font-size: 10px; font-family: Arial,Helvetica,sans-serif;">
									<a href="http://library.books24x7.com/feedback.asp" border="0"></a>
								</span></td>
						</tr>
					</tbody></table>
				</td>
			</tr>
		</tbody></table>
		<!-- This document saved from http://library.books24x7.com/book/id_3429/viewer.asp?pr=1 -->
	</body></html>